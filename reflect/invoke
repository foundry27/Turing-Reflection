unit
module *Invoke
    import Opcodes in "Opcodes.tu",
        InvocationArgument in "invocation/InvocationArgument.tu",
        MutableInvocationArgument in "%oot/reflect/internal/invocation/MutableInvocationArgument.tu"
    export ~.*intArg, ~.*int1Arg, ~.*int2Arg, ~.*int4Arg,
        ~.*natArg, ~.*nat1Arg, ~.*nat2Arg, ~.*nat4Arg,
        ~.*enumArg,
        ~.*pointerArg, ~.*stringArg,
        ~.*realArg, ~.*real4Arg, ~.*real8Arg,
        ~.*booleanArg
    
    /* internally, every integer type takes up 4 bytes on the stack anyways */
    fcn intArg(arg: int): unchecked ^InvocationArgument
        var ops: array 1..* of Opcodes.TYPE := init(
            PUSHINT1, 0
        )
        if (arg > 127) then
            if (arg > 32767) then
                ops(1) := PUSHINT
            else
                ops(1) := PUSHINT2
            end if
        end if
        ops(2) := cheat(nat, arg)
        
        var node: ^MutableInvocationArgument
        new node; node -> construct(ops, sizeof(int));
        result node
    end intArg
    
    fcn int1Arg(arg: int1): unchecked ^InvocationArgument
        result intArg(arg)
    end int1Arg
    
    fcn int2Arg(arg: int2): unchecked ^InvocationArgument
        result intArg(arg)
    end int2Arg
    
    fcn int4Arg(arg: int4): unchecked ^InvocationArgument
        result intArg(arg)
    end int4Arg
    
    /* enums are just integers */
    fcn enumArg(arg: cheat nat): unchecked ^InvocationArgument
        result intArg(arg)
    end enumArg
    
    /* there is no specific stack pushing operation for unsigned integers  */
    fcn natArg(arg: nat): unchecked ^InvocationArgument
        result intArg(arg)
    end natArg
    
    fcn nat1Arg(arg: nat1): unchecked ^InvocationArgument
        result natArg(arg)
    end nat1Arg
    
    fcn nat2Arg(arg: nat2): unchecked ^InvocationArgument
        result natArg(arg)
    end nat2Arg
    
    fcn nat4Arg(arg: nat4): unchecked ^InvocationArgument
        result natArg(arg)
    end nat4Arg
    
    fcn pointerArg(arg: addressint): unchecked ^InvocationArgument
        var ops: array 1..* of Opcodes.TYPE := init(
            PUSHADDR, 0
        )
        ops(2) := arg
        
        var node: ^MutableInvocationArgument
        new node; node -> construct(ops, sizeof(addressint));
        result node
    end pointerArg
    
    fcn realArg(arg: real): unchecked ^InvocationArgument
        var ops: array 1..* of Opcodes.TYPE := init(
            PUSHREAL, 0, 0
        )
        real @ (addr(ops(2))) := arg
        
        var node: ^MutableInvocationArgument
        new node; node -> construct(ops, sizeof(real));
        result node
    end realArg
    
    /* there is no specific stack pushing operation for single-precision floating-point numbers */
    fcn real4Arg(arg: real4): unchecked ^InvocationArgument
        var ops: array 1..* of Opcodes.TYPE := init(
            PUSHREAL, 0, 0
        )
        real4 @ (addr(ops(2))) := arg
        
        var node: ^MutableInvocationArgument
        new node; node -> construct(ops, sizeof(real4));
        result node
    end real4Arg
    
    fcn real8Arg(arg: real8): unchecked ^InvocationArgument
        result realArg(arg)
    end real8Arg
    
    /* strings are all pointers to some region of memory */
    fcn stringArg(arg: string): unchecked ^InvocationArgument
        result pointerArg(addr(arg))
    end stringArg
    
    fcn booleanArg(arg: boolean): unchecked ^InvocationArgument
        var ops: array 1..1 of Opcodes.TYPE
        if (arg) then
            ops(1) := PUSHVAL1
        else
            ops(1) := PUSHVAL0
        end if
        
        var node: ^MutableInvocationArgument
        new node; node -> construct(ops, sizeof(int));
        result node
    end booleanArg
    
end Invoke
